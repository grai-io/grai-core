{"version":3,"sources":["../../src/utils/node-manifest.ts"],"names":["findPageOwnedByNodeId","nodeId","state","store","getState","pages","nodes","byNode","queries","usingPagesMap","process","env","NODE_ENV","pagePathSetOrMap","get","pagePath","values","next","value","foundPageBy","ownerPagePath","foundOwnerNodeId","pathOrPageObject","path","fullPage","ownerNodeId","foundPageIdInContext","context","id","pageCreatedByPluginName","pluginCreatorId","name","pageCreatedByFilesystemPlugin","page","foundPageByToLogIds","none","queryTracking","warnAboutNodeManifestMappingProblems","inputManifest","verbose","logId","reporter","error","Error","processNodeManifest","listOfUniqueErrorIds","nodeManifestPagePathMap","verboseLogs","node","fullNode","noNodeWarningId","pluginName","add","nodeManifestPage","nodeManifestMappingProblemsContext","finalManifest","gatsbySiteDirectory","program","directory","fileNameBase","manifestId","platform","replace","manifestFilePath","join","manifestFileDir","dirname","fs","ensureDir","writeJSON","info","set","processNodeManifests","gatsby_log_level","VERBOSE_NODE_MANIFEST","startTime","Date","now","nodeManifests","totalManifests","length","totalProcessedManifests","totalFailedManifests","Map","Set","processNodeManifestTask","manifest","cb","processedManifest","setImmediate","processNodeManifestQueue","push","idle","Promise","resolve","drain","pluralize","endTime","size","dispatch","internalActions","deleteNodeManifests"],"mappings":";;;;;;;;;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeA,qBAAf,CAAqC;AAAEC,EAAAA;AAAF,CAArC,EAGG;AAAA;;AACD,QAAMC,KAAK,GAAGC,aAAMC,QAAN,EAAd;;AACA,QAAM;AAAEC,IAAAA,KAAF;AAASC,IAAAA;AAAT,MAAmBJ,KAAzB;AACA,QAAM;AAAEK,IAAAA;AAAF,MAAaL,KAAK,CAACM,OAAzB,CAHC,CAKD;AACA;AACA;AACA;AACA;;AACA,QAAMC,aAAsB,GAAI,aAAD,KAAkBC,OAAO,CAACC,GAAR,CAAYC,QAA7D;AAEA,QAAMC,gBAAgB,GAAGJ,aAAa,GAClC;AACAJ,EAAAA,KAFkC,GAGlC;AACAE,EAAAA,MAJkC,aAIlCA,MAJkC,uBAIlCA,MAAM,CAAEO,GAAR,CAAYb,MAAZ,CAJJ,CAZC,CAkBD;AACA;;AAEA,MAAIc,QAAQ,GAAGR,MAAH,aAAGA,MAAH,sCAAGA,MAAM,CAAEO,GAAR,CAAYb,MAAZ,CAAH,sEAAG,YAAqBe,MAArB,EAAH,gFAAG,mBAA+BC,IAA/B,EAAH,0DAAG,sBAAuCC,KAAtD;AAEA,MAAIC,WAAwB,GAAGJ,QAAQ,GAAI,eAAJ,GAAsB,MAA7D;;AAEA,MAAIF,gBAAJ,EAAsB;AACpB,QAAIO,aAAJ;AACA,QAAIC,gBAAgB,GAAG,KAAvB,CAFoB,CAIpB;;AACA,SAAK,MAAMC,gBAAX,IAA+BT,gBAAgB,CAACG,MAAjB,EAA/B,EAA0D;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIK,gBAAJ,EAAsB;AACpB;AACD;;AAED,YAAME,IAAI,GACRd,aAAa,GACT;AACCa,MAAAA,gBAAD,CAAkCC,IAFzB,GAGT;AACAD,MAAAA,gBALN;AAQA,YAAME,QAAiC,GAAGnB,KAAK,CAACS,GAAN,CAAUS,IAAV,CAA1C;AAEAF,MAAAA,gBAAgB,GAAG,CAAAG,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEC,WAAV,MAA0BxB,MAA7C;AAEA,YAAMyB,oBAAoB,GAAG,CAAAF,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEG,OAAV,CAAkBC,EAAlB,MAAyB3B,MAAtD;;AAEA,UAAIoB,gBAAJ,EAAsB;AACpBF,QAAAA,WAAW,GAAI,aAAf;AACD,OAFD,MAEO,IAAIO,oBAAoB,IAAIF,QAA5B,EAAsC;AAAA;;AAC3C,cAAMK,uBAAuB,iBAAGvB,KAAK,CAACQ,GAAN,CAC9BU,QAAQ,CAACM,eADqB,CAAH,+CAAG,WAE7BC,IAFH;AAIA,cAAMC,6BAA6B,GACjCH,uBAAuB,KAAM,4BAD/B;AAGAV,QAAAA,WAAW,GAAGa,6BAA6B,GACtC,sBADsC,GAEtC,YAFL;AAGD;;AAED,UACER,QAAQ,KAGPH,gBAAgB,IACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,MAAAA,oBAZM,CADV,EAcE;AACA;AACAN,QAAAA,aAAa,GAAGI,QAAQ,CAACD,IAAzB;AACD;AACF;;AAED,QAAIH,aAAJ,EAAmB;AACjBL,MAAAA,QAAQ,GAAGK,aAAX;AACD;AACF;;AAED,SAAO;AACLa,IAAAA,IAAI,EAAE;AACJV,MAAAA,IAAI,EAAER,QAAQ,IAAI;AADd,KADD;AAILI,IAAAA;AAJK,GAAP;AAMD,C,CAED;AACA;;;AACO,MAAMe,mBAAmB,GAAG;AACjCC,EAAAA,IAAI,EAAG,OAD0B;AAEjC,GAAE,YAAF,GAAiB,OAFgB;AAGjCC,EAAAA,aAAa,EAAG,OAHiB;AAIjC,GAAE,sBAAF,GAA2B,SAJM;AAKjCX,EAAAA,WAAW,EAAG;AALmB,CAA5B;AAQP;AACA;AACA;;;;AACO,SAASY,oCAAT,CAA8C;AACnDC,EAAAA,aADmD;AAEnDvB,EAAAA,QAFmD;AAGnDI,EAAAA,WAHmD;AAInDoB,EAAAA;AAJmD,CAA9C,EAUe;AACpB,MAAIC,KAAJ;;AAEA,UAAQrB,WAAR;AACE,SAAM,MAAN;AACA,SAAM,YAAN;AACA,SAAM,eAAN;AAAsB;AACpBqB,QAAAA,KAAK,GAAGN,mBAAmB,CAACf,WAAD,CAA3B;;AACA,YAAIoB,OAAJ,EAAa;AACXE,4BAASC,KAAT,CAAe;AACbd,YAAAA,EAAE,EAAEY,KADS;AAEbb,YAAAA,OAAO,EAAE;AACPW,cAAAA,aADO;AAEPvB,cAAAA;AAFO;AAFI,WAAf;AAOD;;AACD;AACD;;AAED,SAAM,sBAAN;AACA,SAAM,aAAN;AACEyB,MAAAA,KAAK,GAAI,SAAT;AACA;;AAEF;AAAS;AACP,cAAMG,KAAK,CAAE,iDAAF,CAAX;AACD;AAxBH;;AA2BA,SAAO;AACLH,IAAAA;AADK,GAAP;AAGD;AAED;AACA;AACA;;;AACO,eAAeI,mBAAf,CACLN,aADK,EAELO,oBAFK,EAGLC,uBAHK,EAILC,WAJK,EAK6B;AAClC,QAAM9C,MAAM,GAAGqC,aAAa,CAACU,IAAd,CAAmBpB,EAAlC;AACA,QAAMqB,QAAQ,GAAG,wBAAQhD,MAAR,CAAjB;AACA,QAAMiD,eAAe,GAAI,OAAzB;;AAEA,MAAI,CAACD,QAAL,EAAe;AACb,QAAIF,WAAJ,EAAiB;AACfN,wBAASC,KAAT,CAAe;AACbd,QAAAA,EAAE,EAAEsB,eADS;AAEbvB,QAAAA,OAAO,EAAE;AACPwB,UAAAA,UAAU,EAAEb,aAAa,CAACa,UADnB;AAEPlD,UAAAA;AAFO;AAFI,OAAf;AAOD,KARD,MAQO;AACL4C,MAAAA,oBAAoB,CAACO,GAArB,CAAyBF,eAAzB;AACD;;AAED,WAAO,IAAP;AACD,GAnBiC,CAqBlC;;;AACA,QAAM;AAAEjB,IAAAA,IAAI,EAAEoB,gBAAR;AAA0BlC,IAAAA;AAA1B,MAA0C,MAAMnB,qBAAqB,CAAC;AAC1EC,IAAAA;AAD0E,GAAD,CAA3E;AAIA,QAAMqD,kCAAkC,GAAG;AACzChB,IAAAA,aADyC;AAEzCvB,IAAAA,QAAQ,EAAEsC,gBAAgB,CAAC9B,IAFc;AAGzCJ,IAAAA,WAHyC;AAIzCoB,IAAAA,OAAO,EAAEQ;AAJgC,GAA3C;;AAOA,MAAIA,WAAJ,EAAiB;AACfV,IAAAA,oCAAoC,CAACiB,kCAAD,CAApC;AACD,GAFD,MAEO;AACL,UAAM;AAAEd,MAAAA;AAAF,QAAYH,oCAAoC,CACpDiB,kCADoD,CAAtD;;AAIA,QAAId,KAAK,KAAM,SAAf,EAAyB;AACvBK,MAAAA,oBAAoB,CAACO,GAArB,CAAyBZ,KAAzB;AACD;AACF;;AAED,QAAMe,aAA+B,GAAG;AACtCP,IAAAA,IAAI,EAAEV,aAAa,CAACU,IADkB;AAEtCf,IAAAA,IAAI,EAAEoB,gBAFgC;AAGtClC,IAAAA;AAHsC,GAAxC;;AAMA,QAAMqC,mBAAmB,GAAGrD,aAAMC,QAAN,GAAiBqD,OAAjB,CAAyBC,SAArD;;AAEA,MAAIC,YAAY,GAAGrB,aAAa,CAACsB,UAAjC;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,MAAIlD,OAAO,CAACmD,QAAR,KAAsB,OAA1B,EAAkC;AAChCF,IAAAA,YAAY,GAAGA,YAAY,CAACG,OAAb,CAAqB,yBAArB,EAAiD,GAAjD,CAAf;AACD,GAvEiC,CAyElC;;;AACA,QAAMC,gBAAgB,GAAGxC,cAAKyC,IAAL,CACvBR,mBADuB,EAEtB,QAFsB,EAGtB,kBAHsB,EAIvBlB,aAAa,CAACa,UAJS,EAKtB,GAAEQ,YAAa,OALO,CAAzB;;AAQA,QAAMM,eAAe,GAAG1C,cAAK2C,OAAL,CAAaH,gBAAb,CAAxB;;AAEA,QAAMI,iBAAGC,SAAH,CAAaH,eAAb,CAAN;AACA,QAAME,iBAAGE,SAAH,CAAaN,gBAAb,EAA+BR,aAA/B,CAAN;;AAEA,MAAIR,WAAJ,EAAiB;AACfN,sBAAS6B,IAAT,CACG,UAAShC,aAAa,CAACa,UAAW,mCAAkCQ,YAAa,EADpF;AAGD;;AAED,MAAIN,gBAAgB,CAAC9B,IAArB,EAA2B;AACzBuB,IAAAA,uBAAuB,CAACyB,GAAxB,CAA4BlB,gBAAgB,CAAC9B,IAA7C,EAAmDoC,YAAnD;AACD;;AAED,SAAOJ,aAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,eAAeiB,oBAAf,GAGG;AACR,QAAMzB,WAAW,GACfrC,OAAO,CAACC,GAAR,CAAY8D,gBAAZ,KAAkC,SAAlC,IACA/D,OAAO,CAACC,GAAR,CAAY+D,qBAAZ,KAAuC,MAFzC;AAIA,QAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAoB3E,aAAMC,QAAN,EAA1B;;AAEA,QAAM2E,cAAc,GAAGD,aAAa,CAACE,MAArC;;AAEA,MAAID,cAAc,KAAK,CAAvB,EAA0B;AACxB,WAAO,IAAP;AACD;;AAED,MAAIE,uBAAuB,GAAG,CAA9B;AACA,MAAIC,oBAAoB,GAAG,CAA3B;AACA,QAAMpC,uBAA4C,GAAG,IAAIqC,GAAJ,EAArD;AACA,QAAMtC,oBAAiC,GAAG,IAAIuC,GAAJ,EAA1C;;AAEA,iBAAeC,uBAAf,CACEC,QADF,EAEEC,EAFF,EAGiB;AACf,UAAMC,iBAAiB,GAAG,MAAM5C,mBAAmB,CACjD0C,QADiD,EAEjDzC,oBAFiD,EAGjDC,uBAHiD,EAIjDC,WAJiD,CAAnD;;AAOA,QAAIyC,iBAAJ,EAAuB;AACrBP,MAAAA,uBAAuB;AACxB,KAFD,MAEO;AACLC,MAAAA,oBAAoB;AACrB,KAZc,CAcf;AACA;;;AACAO,IAAAA,YAAY,CAAC,MAAMF,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT,CAAZ;AACA;AACD;;AAED,QAAMG,wBAAwB,GAAG,oBAAML,uBAAN,EAA+B,EAA/B,CAAjC;;AAEA,OAAK,MAAMC,QAAX,IAAuBR,aAAvB,EAAsC;AACpCY,IAAAA,wBAAwB,CAACC,IAAzB,CAA8BL,QAA9B,EAAwC,MAAM,CAAE,CAAhD;AACD;;AAED,MAAI,CAACI,wBAAwB,CAACE,IAAzB,EAAL,EAAsC;AACpC,UAAM,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC3BJ,MAAAA,wBAAwB,CAACK,KAAzB,GAAiCD,OAAjC;AACD,KAFK,CAAN;AAGD;;AAED,QAAME,SAAS,GAAIhB,MAAD,IAChBA,MAAM,GAAG,CAAT,IAAcA,MAAM,KAAK,CAAzB,GAA8B,GAA9B,GAAoC,EADtC;;AAGA,QAAMiB,OAAO,GAAGrB,IAAI,CAACC,GAAL,EAAhB;;AAEApC,oBAAS6B,IAAT,CACG,aAAYW,uBAAwB,2BAA0Be,SAAS,CACtEf,uBADsE,CAEtE,OAAMgB,OAAO,GAAGtB,SAAU,QAC1BO,oBAAoB,GAAG,CAAvB,GACK,KAAIA,oBAAqB,YAAWc,SAAS,CAC5Cd,oBAD4C,CAE5C,yBAHN,GAIK,EACN,EATH;;AAYAzC,oBAAS6B,IAAT,CACE,CAAC,CAACvB,WAAD,IAAgBF,oBAAoB,CAACqD,IAArB,GAA4B,CAA5C,GACI,kDAAiD,CAChD,GAAGrD,oBAD6C,EAEhDmB,IAFgD,CAE1C,IAF0C,CAErC,KAHhB,GAII,EAJL,IAKG,uJANL,EAvEQ,CAgFR;;;AACA7D,eAAMgG,QAAN,CAAeC,yBAAgBC,mBAAhB,EAAf;;AACA,SAAOvD,uBAAP;AACD","sourcesContent":["import type { ErrorId } from \"gatsby-cli/lib/structured-errors/error-map\"\nimport { getNode } from \"./../datastore\"\nimport { IGatsbyPage, INodeManifest } from \"./../redux/types\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport { store } from \"../redux/\"\nimport { internalActions } from \"../redux/actions\"\nimport path from \"path\"\nimport fs from \"fs-extra\"\nimport fastq from \"fastq\"\n\ninterface INodeManifestPage {\n  path?: string\n}\n\n/**\n * This it the output after processing calls to the public unstable_createNodeManifest action\n */\ninterface INodeManifestOut {\n  page: INodeManifestPage\n  node: {\n    id: string\n  }\n  foundPageBy: FoundPageBy\n}\n\ntype FoundPageBy =\n  | `ownerNodeId`\n  | `filesystem-route-api`\n  // for these three we warn to use ownerNodeId instead\n  | `context.id`\n  | `queryTracking`\n  | `none`\n\n/**\n * Finds a final built page by nodeId\n *\n * Note that this function wont work properly in `gatsby develop`\n * since develop no longer runs all page queries when creating pages.\n * We use the node id to query mapping to find the right page but\n * this mapping only exists once you've visited a page in your browser.\n * When this fn is being used for routing to previews the user wont necessarily have\n * visited the page in the browser yet.\n */\nasync function findPageOwnedByNodeId({ nodeId }: { nodeId: string }): Promise<{\n  page: INodeManifestPage\n  foundPageBy: FoundPageBy\n}> {\n  const state = store.getState()\n  const { pages, nodes } = state\n  const { byNode } = state.queries\n\n  // in development queries are run on demand so we wont have an accurate nodeId->pages map until those pages are visited in the browser. We want this mapping before the page is visited in the browser so we can route to the right page in the browser.\n  // So in development we can just use the Map of all pages (pagePath -> pageNode)\n  // but for builds (preview inc builds or regular builds) we will have a full map\n  // of all nodeId's to pages they're queried on and we can use that instead since it\n  // will be a much smaller list of pages, resulting in better performance for large sites\n  const usingPagesMap: boolean = `development` === process.env.NODE_ENV\n\n  const pagePathSetOrMap = usingPagesMap\n    ? // this is a Map of page path to page node\n      pages\n    : // this is a Set of page paths\n      byNode?.get(nodeId)\n\n  // the default page path is the first page found in\n  // node id to page query tracking\n\n  let pagePath = byNode?.get(nodeId)?.values()?.next()?.value\n\n  let foundPageBy: FoundPageBy = pagePath ? `queryTracking` : `none`\n\n  if (pagePathSetOrMap) {\n    let ownerPagePath: string | undefined\n    let foundOwnerNodeId = false\n\n    // for each page this nodeId is queried in\n    for (const pathOrPageObject of pagePathSetOrMap.values()) {\n      // if we haven't found a page with this nodeId\n      // set as page.ownerNodeId then run this logic.\n      // this condition is on foundOwnerNodeId instead of ownerPagePath\n      // in case we find a page with the nodeId in page.context.id\n      // and then later in the loop there's a page with this nodeId\n      // set on page.ownerNodeId.\n      // We always want to prefer ownerPagePath over context.id\n      if (foundOwnerNodeId) {\n        break\n      }\n\n      const path = (\n        usingPagesMap\n          ? // in development we're using a Map, so the value here is a page object\n            (pathOrPageObject as IGatsbyPage).path\n          : // in builds we're using a Set so the page path is the value\n            pathOrPageObject\n      ) as string\n\n      const fullPage: IGatsbyPage | undefined = pages.get(path)\n\n      foundOwnerNodeId = fullPage?.ownerNodeId === nodeId\n\n      const foundPageIdInContext = fullPage?.context.id === nodeId\n\n      if (foundOwnerNodeId) {\n        foundPageBy = `ownerNodeId`\n      } else if (foundPageIdInContext && fullPage) {\n        const pageCreatedByPluginName = nodes.get(\n          fullPage.pluginCreatorId\n        )?.name\n\n        const pageCreatedByFilesystemPlugin =\n          pageCreatedByPluginName === `gatsby-plugin-page-creator`\n\n        foundPageBy = pageCreatedByFilesystemPlugin\n          ? `filesystem-route-api`\n          : `context.id`\n      }\n\n      if (\n        fullPage &&\n        // first check for the ownerNodeId on the page. this is\n        // the defacto owner. Can't get more specific than this\n        (foundOwnerNodeId ||\n          // if there's no specified owner look to see if\n          // pageContext has an `id` variable which matches our\n          // nodeId. Using an \"id\" as a variable in queries is common\n          // and if we don't have an owner this is a better guess\n          // of an owner than grabbing the first page query we find\n          // that's mapped to this node id.\n          // this also makes this work with the filesystem Route API without\n          // changing that API.\n          foundPageIdInContext)\n      ) {\n        // save this path to use in our manifest!\n        ownerPagePath = fullPage.path\n      }\n    }\n\n    if (ownerPagePath) {\n      pagePath = ownerPagePath\n    }\n  }\n\n  return {\n    page: {\n      path: pagePath || null,\n    },\n    foundPageBy,\n  }\n}\n\n// these id's correspond to error id's in\n// packages/gatsby-cli/src/structured-errors/error-map.ts\nexport const foundPageByToLogIds = {\n  none: `11801`,\n  [`context.id`]: `11802`,\n  queryTracking: `11803`,\n  [`filesystem-route-api`]: `success`,\n  ownerNodeId: `success`,\n}\n\n/**\n * Takes in some info about a node manifest and the page we did or didn't find for it, then warns and returns the warning string\n */\nexport function warnAboutNodeManifestMappingProblems({\n  inputManifest,\n  pagePath,\n  foundPageBy,\n  verbose,\n}: {\n  inputManifest: INodeManifest\n  pagePath?: string\n  foundPageBy: FoundPageBy\n  verbose: boolean\n}): { logId: string } {\n  let logId: ErrorId | `success`\n\n  switch (foundPageBy) {\n    case `none`:\n    case `context.id`:\n    case `queryTracking`: {\n      logId = foundPageByToLogIds[foundPageBy]\n      if (verbose) {\n        reporter.error({\n          id: logId,\n          context: {\n            inputManifest,\n            pagePath,\n          },\n        })\n      }\n      break\n    }\n\n    case `filesystem-route-api`:\n    case `ownerNodeId`:\n      logId = `success`\n      break\n\n    default: {\n      throw Error(`Node Manifest mapping is in an impossible state`)\n    }\n  }\n\n  return {\n    logId,\n  }\n}\n\n/**\n * Prepares and then writes out an individual node manifest file to be used for routing to previews. Manifest files are added via the public unstable_createNodeManifest action\n */\nexport async function processNodeManifest(\n  inputManifest: INodeManifest,\n  listOfUniqueErrorIds: Set<string>,\n  nodeManifestPagePathMap: Map<string, string>,\n  verboseLogs: boolean\n): Promise<null | INodeManifestOut> {\n  const nodeId = inputManifest.node.id\n  const fullNode = getNode(nodeId)\n  const noNodeWarningId = `11804`\n\n  if (!fullNode) {\n    if (verboseLogs) {\n      reporter.error({\n        id: noNodeWarningId,\n        context: {\n          pluginName: inputManifest.pluginName,\n          nodeId,\n        },\n      })\n    } else {\n      listOfUniqueErrorIds.add(noNodeWarningId)\n    }\n\n    return null\n  }\n\n  // map the node to a page that was created\n  const { page: nodeManifestPage, foundPageBy } = await findPageOwnedByNodeId({\n    nodeId,\n  })\n\n  const nodeManifestMappingProblemsContext = {\n    inputManifest,\n    pagePath: nodeManifestPage.path,\n    foundPageBy,\n    verbose: verboseLogs,\n  }\n\n  if (verboseLogs) {\n    warnAboutNodeManifestMappingProblems(nodeManifestMappingProblemsContext)\n  } else {\n    const { logId } = warnAboutNodeManifestMappingProblems(\n      nodeManifestMappingProblemsContext\n    )\n\n    if (logId !== `success`) {\n      listOfUniqueErrorIds.add(logId)\n    }\n  }\n\n  const finalManifest: INodeManifestOut = {\n    node: inputManifest.node,\n    page: nodeManifestPage,\n    foundPageBy,\n  }\n\n  const gatsbySiteDirectory = store.getState().program.directory\n\n  let fileNameBase = inputManifest.manifestId\n\n  /**\n   * Windows has a handful of special/reserved characters that are not valid in a file path\n   * @reference https://superuser.com/questions/358855/what-characters-are-safe-in-cross-platform-file-names-for-linux-windows-and-os\n   *\n   * The two exceptions to the list linked above are\n   * - the colon that is part of the hard disk partition name at the beginning of a file path (i.e. C:)\n   * - backslashes. We don't want to replace backslashes because those are used to delineate what the actual file path is\n   *\n   * During local development, node manifests can be written to disk but are generally unused as they are only used\n   * for Content Sync which runs in Gatsby Cloud. Gatsby cloud is a Linux environment in which these special chars are valid in\n   * filepaths. To avoid errors on Windows, we replace all instances of the special chars in the filepath (with the exception of the\n   * hard disk partition name) with \"-\" to ensure that local Windows development setups do not break when attempting\n   * to write one of these manifests to disk.\n   */\n  if (process.platform === `win32`) {\n    fileNameBase = fileNameBase.replace(/:|\\/|\\*|\\?|\"|<|>|\\||\\\\/g, `-`)\n  }\n\n  // write out the manifest file\n  const manifestFilePath = path.join(\n    gatsbySiteDirectory,\n    `public`,\n    `__node-manifests`,\n    inputManifest.pluginName,\n    `${fileNameBase}.json`\n  )\n\n  const manifestFileDir = path.dirname(manifestFilePath)\n\n  await fs.ensureDir(manifestFileDir)\n  await fs.writeJSON(manifestFilePath, finalManifest)\n\n  if (verboseLogs) {\n    reporter.info(\n      `Plugin ${inputManifest.pluginName} created a manifest with the id ${fileNameBase}`\n    )\n  }\n\n  if (nodeManifestPage.path) {\n    nodeManifestPagePathMap.set(nodeManifestPage.path, fileNameBase)\n  }\n\n  return finalManifest\n}\n\n/**\n * Grabs all pending node manifests, processes them, writes them to disk,\n * and then removes them from the store.\n * Manifest files are added via the public unstable_createNodeManifest action in sourceNodes\n */\nexport async function processNodeManifests(): Promise<Map<\n  string,\n  string\n> | null> {\n  const verboseLogs =\n    process.env.gatsby_log_level === `verbose` ||\n    process.env.VERBOSE_NODE_MANIFEST === `true`\n\n  const startTime = Date.now()\n  const { nodeManifests } = store.getState()\n\n  const totalManifests = nodeManifests.length\n\n  if (totalManifests === 0) {\n    return null\n  }\n\n  let totalProcessedManifests = 0\n  let totalFailedManifests = 0\n  const nodeManifestPagePathMap: Map<string, string> = new Map()\n  const listOfUniqueErrorIds: Set<string> = new Set()\n\n  async function processNodeManifestTask(\n    manifest: INodeManifest,\n    cb: fastq.done<any>\n  ): Promise<void> {\n    const processedManifest = await processNodeManifest(\n      manifest,\n      listOfUniqueErrorIds,\n      nodeManifestPagePathMap,\n      verboseLogs\n    )\n\n    if (processedManifest) {\n      totalProcessedManifests++\n    } else {\n      totalFailedManifests++\n    }\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many manifests\n    setImmediate(() => cb(null, true))\n    return\n  }\n\n  const processNodeManifestQueue = fastq(processNodeManifestTask, 25)\n\n  for (const manifest of nodeManifests) {\n    processNodeManifestQueue.push(manifest, () => {})\n  }\n\n  if (!processNodeManifestQueue.idle()) {\n    await new Promise(resolve => {\n      processNodeManifestQueue.drain = resolve as () => unknown\n    })\n  }\n\n  const pluralize = (length: number): string =>\n    length > 1 || length === 0 ? `s` : ``\n\n  const endTime = Date.now()\n\n  reporter.info(\n    `Wrote out ${totalProcessedManifests} node page manifest file${pluralize(\n      totalProcessedManifests\n    )} in ${endTime - startTime} ms. ${\n      totalFailedManifests > 0\n        ? `. ${totalFailedManifests} manifest${pluralize(\n            totalFailedManifests\n          )} couldn't be processed.`\n        : ``\n    }`\n  )\n\n  reporter.info(\n    (!verboseLogs && listOfUniqueErrorIds.size > 0\n      ? `unstable_createNodeManifest produced warnings [${[\n          ...listOfUniqueErrorIds,\n        ].join(`, `)}]. `\n      : ``) +\n      `To see full warning messages set process.env.VERBOSE_NODE_MANIFEST to \"true\".\\nVisit https://gatsby.dev/nodemanifest for more info on Node Manifests.`\n  )\n\n  // clean up all pending manifests from the store\n  store.dispatch(internalActions.deleteNodeManifests())\n  return nodeManifestPagePathMap\n}\n"],"file":"node-manifest.js"}